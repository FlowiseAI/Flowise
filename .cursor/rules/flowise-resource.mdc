---
description: Flowise Resource Implementation Architecture
globs: 
alwaysApply: false
---
# Flowise Resource Implementation Architecture

This rule documents the standardized patterns for implementing resources (like "Chatflow") across the Flowise codebase, covering both server-side and client-side implementations.

## Server Architecture Pattern

### 1. Routes Layer (`packages/server/src/routes/{resource}/index.ts`)
- **Purpose**: Express route definitions with authentication middleware
- **Pattern**: RESTful endpoint mapping to controller methods
- **Structure**:
  ```typescript
  import express from 'express'
  import {resource}Controller from '../../controllers/{resource}'
  import enforceAbility from '../../middlewares/authentication/enforceAbility'
  
  const router = express.Router()
  
  // CREATE
  router.post('/', enforceAbility('{Resource}'), {resource}Controller.save{Resource})
  router.post('/import{resource}s', enforceAbility('{Resource}'), {resource}Controller.import{Resource}s)
  
  // READ
  router.get('/', enforceAbility('{Resource}'), {resource}Controller.getAll{Resource}s)
  router.get(['/', '/:id'], enforceAbility('{Resource}'), {resource}Controller.get{Resource}ById)
  router.get(['/apikey/', '/apikey/:apikey'], enforceAbility('{Resource}'), {resource}Controller.get{Resource}ByApiKey)
  
  // UPDATE
  router.put(['/', '/:id'], enforceAbility('{Resource}'), {resource}Controller.update{Resource})
  
  // DELETE
  router.delete(['/', '/:id'], enforceAbility('{Resource}'), {resource}Controller.delete{Resource})
  ```

### 2. Controllers Layer (`packages/server/src/controllers/{resource}/index.ts`)
- **Purpose**: Request/response handling, validation, error handling
- **Pattern**: Async functions that delegate to services
- **Key Responsibilities**:
  - Request parameter validation
  - User authentication/authorization checks
  - Calling service layer methods
  - Error handling with try/catch
  - HTTP response formatting
- **Structure**:
  ```typescript
  import { NextFunction, Request, Response } from 'express'
  import { StatusCodes } from 'http-status-codes'
  import {resource}Service from '../../services/{resource}'
  import { InternalFlowiseError } from '../../errors/internalFlowiseError'
  import checkOwnership from '../../utils/checkOwnership'
  
  const get{Resource}ById = async (req: Request, res: Response, next: NextFunction) => {
      try {
          if (!req.params.id) {
              throw new InternalFlowiseError(StatusCodes.PRECONDITION_FAILED, 'ID required')
          }
          const apiResponse = await {resource}Service.get{Resource}ById(req.params.id, req.user)
          
          // Authorization checks
          if (req.user && !(await checkOwnership(apiResponse, req.user, req))) {
              throw new InternalFlowiseError(StatusCodes.UNAUTHORIZED, 'Unauthorized')
          }
          
          return res.json(apiResponse)
      } catch (error) {
          next(error)
      }
  }
  ```

### 3. Services Layer (`packages/server/src/services/{resource}/index.ts`)
- **Purpose**: Business logic, data processing, database operations
- **Pattern**: Pure business logic functions with database interactions
- **Key Responsibilities**:
  - Database queries and mutations
  - Business rule validation
  - Data transformation
  - Complex operations (file handling, external API calls)
- **Structure**:
  ```typescript
  import { getRunningExpressApp } from '../../utils/getRunningExpressApp'
  import { {Resource} } from '../../database/entities/{Resource}'
  import { InternalFlowiseError } from '../../errors/internalFlowiseError'
  import { StatusCodes } from 'http-status-codes'
  
  const get{Resource}ById = async (id: string, user?: IUser): Promise<{Resource}> => {
      try {
          const appServer = getRunningExpressApp()
          const dbResponse = await appServer.AppDataSource.getRepository({Resource})
              .createQueryBuilder('{resource}')
              .where('{resource}.id = :id', { id })
              .getOne()
              
          if (!dbResponse) {
              throw new InternalFlowiseError(StatusCodes.NOT_FOUND, `{Resource} not found`)
          }
          
          return dbResponse
      } catch (error) {
          throw new InternalFlowiseError(
              StatusCodes.INTERNAL_SERVER_ERROR,
              `Error: {resource}Service.get{Resource}ById - ${getErrorMessage(error)}`
          )
      }
  }
  ```

### 4. Entities Layer (`packages/server/src/database/entities/{Resource}.ts`)
- **Purpose**: TypeORM database model definitions
- **Pattern**: Class-based entities with decorators
- **Key Features**:
  - UUID primary keys
  - Audit fields (createdDate, updatedDate, deletedDate)
  - User/Organization relationships
  - Soft delete support
- **Structure**:
  ```typescript
  import { Entity, Column, Index, CreateDateColumn, UpdateDateColumn, PrimaryGeneratedColumn, DeleteDateColumn } from 'typeorm'
  
  @Entity()
  export class {Resource} {
      @PrimaryGeneratedColumn('uuid')
      id: string
      
      @Column()
      name: string
      
      @Column({ nullable: true, type: 'text' })
      description?: string
      
      @Index()
      @Column({ type: 'uuid', nullable: true })
      userId: string
      
      @Index()
      @Column({ type: 'uuid', nullable: true })
      organizationId: string
      
      @CreateDateColumn()
      createdDate: Date
      
      @UpdateDateColumn()
      updatedDate: Date
      
      @DeleteDateColumn()
      deletedDate: Date
  }
  ```

## Client Architecture Pattern

### 1. API Client (`packages/ui/src/api/{resource}.js`)
- **Purpose**: HTTP client functions that mirror server endpoints
- **Pattern**: Simple functions wrapping HTTP calls
- **Structure**:
  ```javascript
  import client from './client'
  
  const getAll{Resource}s = () => client.get('/{resource}s')
  const get{Resource}ById = (id) => client.get(`/{resource}s/${id}`)
  const create{Resource} = (body) => client.post('/{resource}s', body)
  const update{Resource} = (id, body) => client.put(`/{resource}s/${id}`, body)
  const delete{Resource} = (id) => client.delete(`/{resource}s/${id}`)
  
  export default {
      getAll{Resource}s,
      get{Resource}ById,
      create{Resource},
      update{Resource},
      delete{Resource}
  }
  ```

### 2. Custom Hooks (`packages/ui/src/hooks/useApi.jsx`)
- **Purpose**: React hooks for API state management
- **Pattern**: Reusable hook pattern for async operations
- **Features**:
  - Loading states
  - Error handling
  - Data caching
  - Automatic authentication redirect
- **Usage**:
  ```javascript
  const get{Resource}sApi = useApi({resource}Api.getAll{Resource}s)
  
  useEffect(() => {
      get{Resource}sApi.request()
  }, [])
  ```

### 3. Views/Components (`packages/ui/src/views/{resource}/index.jsx`)
- **Purpose**: UI components and page layouts
- **Pattern**: React functional components with hooks
- **Key Features**:
  - State management with useState/useEffect
  - API integration via custom hooks
  - Material-UI components
  - Error boundaries
  - Search and filtering
  - Multiple view modes (card/list)
- **Structure**:
  ```javascript
  import { useEffect, useState } from 'react'
  import { useNavigate } from 'react-router-dom'
  import {resource}Api from '@/api/{resource}'
  import useApi from '@/hooks/useApi'
  
  const {Resource}s = () => {
      const navigate = useNavigate()
      const [search, setSearch] = useState('')
      const get{Resource}sApi = useApi({resource}Api.getAll{Resource}s)
      
      useEffect(() => {
          get{Resource}sApi.request()
      }, [])
      
      const addNew = () => navigate('/canvas')
      const goTo{Resource} = (selected{Resource}) => navigate(`/canvas/${selected{Resource}.id}`)
      
      return (
          <MainCard>
              <ViewHeader onSearchChange={setSearch} title="{Resource}s">
                  <StyledButton onClick={addNew}>Add New</StyledButton>
              </ViewHeader>
              <ItemGrid data={get{Resource}sApi.data} onClick={goTo{Resource}} />
          </MainCard>
      )
  }
  ```

### 4. Web App Layer (`apps/web/app/`)
- **Purpose**: Next.js application with additional API routes
- **Pattern**: App router with nested layouts
- **Features**:
  - SSR/SSG capabilities
  - Additional API endpoints
  - Authentication integration
  - Multi-tenant support

## Implementation Guidelines

### When Creating New Resources:

1. **Server Implementation**:
   - Create route file in `packages/server/src/routes/{resource}/`
   - Implement controller in `packages/server/src/controllers/{resource}/`
   - Add service logic in `packages/server/src/services/{resource}/`
   - Define entity in `packages/server/src/database/entities/`
   - Register routes in main router

2. **Client Implementation**:
   - Add API client in `packages/ui/src/api/{resource}.js`
   - Create view component in `packages/ui/src/views/{resource}/`
   - Add routing configuration
   - Update navigation menus

### Common Patterns to Follow:

- **Error Handling**: Use `InternalFlowiseError` with appropriate HTTP status codes
- **Authentication**: Apply `enforceAbility` middleware to all protected routes
- **Authorization**: Check ownership with `checkOwnership` utility
- **Validation**: Validate all inputs in controllers before processing
- **Async Operations**: Always use try/catch blocks with proper error forwarding
- **Database Queries**: Use TypeORM query builders for complex operations
- **State Management**: Use custom hooks for API state on client
- **UI Consistency**: Follow Material-UI design patterns with theme integration

### Security Considerations:

- All routes must have authentication middleware
- Implement proper authorization checks
- Validate all user inputs
- Use parameterized queries
- Implement rate limiting where appropriate
- Follow principle of least privilege for user permissions 